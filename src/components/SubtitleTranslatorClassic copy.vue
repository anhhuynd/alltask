<template>
  <div class="translator-container">
    <!-- Header Section -->
    <div class="header-section">
      <div class="header-content">
        <div class="header-icon">🌐</div>
        <div class="header-text">
          <h1 class="header-title">Subtitle Translator</h1>
          <p class="header-subtitle">AI-powered subtitle translation with chunked processing</p>
        </div>
      </div>
    </div>

    <!-- API Settings Card -->
  
    <!-- Language Settings Card -->
    <div class="card language-card">
      <div class="card-header info">
        <div class="card-icon">🌐</div>
        <h3 class="card-title">Language Settings</h3>
      </div>
      <div class="card-content">
        <div class="language-grid">
          <div class="form-group">
            <label class="form-label">Dịch từ:</label>
            <select v-model="sourceLanguage" class="form-select">
              <option value="chinese">🇨🇳 Tiếng Trung</option>
              <option value="english">🇺🇸 Tiếng Anh</option>
              <option value="japanese">🇯🇵 Tiếng Nhật</option>
              <option value="korean">🇰🇷 Tiếng Hàn</option>
              <option value="french">🇫🇷 Tiếng Pháp</option>
              <option value="german">🇩🇪 Tiếng Đức</option>
              <option value="spanish">🇪🇸 Tiếng Tây Ban Nha</option>
              <option value="thai">🇹🇭 Tiếng Thái</option>
            </select>
          </div>
          
          <div class="arrow-container">
            <div class="arrow-icon">→</div>
          </div>
          
          <div class="form-group">
            <label class="form-label">Dịch sang:</label>
            <select v-model="targetLanguage" class="form-select">
              <option value="vietnamese">🇻🇳 Tiếng Việt</option>
              <option value="english">🇺🇸 Tiếng Anh</option>
              <option value="chinese">🇨🇳 Tiếng Trung</option>
              <option value="japanese">🇯🇵 Tiếng Nhật</option>
              <option value="korean">🇰🇷 Tiếng Hàn</option>
              <option value="french">🇫🇷 Tiếng Pháp</option>
              <option value="german">🇩🇪 Tiếng Đức</option>
              <option value="spanish">🇪🇸 Tiếng Tây Ban Nha</option>
              <option value="thai">🇹🇭 Tiếng Thái</option>
            </select>
          </div>
        </div>
      </div>
    </div>

    <!-- File Management Card -->
    <div class="card file-card">
      <div class="card-header warning">
        <div class="card-icon">📁</div>
        <h3 class="card-title">File Management</h3>
      </div>
      <div class="card-content">
        <div class="file-grid">
          <div class="file-upload-section">
            <label class="form-label">Import File (*.txt, *.srt):</label>
            <div class="file-input-wrapper">
              <input 
                type="file" 
                @change="handleFile" 
                accept=".txt,.srt"
                class="file-input"
                id="file-upload"
                ref="fileInput"
              />
              <label for="file-upload" class="file-input-label">
                <span class="upload-icon">📄</span>
                <span class="upload-text">Choose File</span>
              </label>
              <div v-if="selectedFileName" class="file-name">
                <span class="file-icon">📄</span>
                <span class="file-text">{{ selectedFileName }}</span>
              </div>
            </div>
          </div>
          
          <div class="folder-section">
            <label class="form-label">Output Folder:</label>
            <button 
              @click="chooseFolder" 
              :disabled="isRunning"
              class="btn btn-primary folder-btn"
            >
              <span class="btn-icon">📂</span>
              <span>{{ folderPath ? 'Folder Selected' : 'Choose Folder' }}</span>
            </button>
          </div>
        </div>

        <div v-if="folderPath" class="folder-display">
          <div class="folder-info">
            <span class="folder-icon">📁</span>
            <span class="folder-path">{{ folderPath }}</span>
          </div>
        </div>
      </div>
    </div>

    <!-- File Info Card -->
    <div v-if="subtitles && subtitles.length > 0" class="card info-card">
      <div class="card-header info">
        <div class="card-icon">📊</div>
        <h3 class="card-title">File Information</h3>
      </div>
      <div class="card-content">
        <div class="info-grid">
          <div class="info-item">
            <div class="info-icon">🧩</div>
            <div class="info-content">
              <div class="info-number">{{ chunks.length }}</div>
              <div class="info-label">Chunks</div>
              <div class="info-desc">Each < 3 minutes</div>
            </div>
          </div>
          <div class="info-item">
            <div class="info-icon">⏱️</div>
            <div class="info-content">
              <div class="info-number">{{ totalDuration }}</div>
              <div class="info-label">Total Duration</div>
              <div class="info-desc">Full video length</div>
            </div>
          </div>
          <div class="info-item">
            <div class="info-icon">📝</div>
            <div class="info-content">
              <div class="info-number">{{ subtitles.length }}</div>
              <div class="info-label">Subtitles</div>
              <div class="info-desc">Total entries</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Processing Control -->
    <div v-if="subtitles && subtitles.length > 0" class="card control-card">
      <div class="card-content">
        <button 
          @click="start" 
          :disabled="isRunning || !apiKey || !folderPath"
          class="btn btn-start"
          :class="{ 'processing': isRunning }"
        >
          <div v-if="!isRunning" class="btn-content">
            <span class="btn-icon">▶️</span>
            <span class="btn-text">Start Translation</span>
          </div>
          <div v-else class="btn-content processing">
            <div class="loading-spinner"></div>
            <span class="btn-text">Translating Subtitles...</span>
          </div>
        </button>
        
        <div v-if="isRunning" class="progress-section">
          <div class="progress-bar">
            <div class="progress-fill" :style="{ width: progressPercentage + '%' }"></div>
          </div>
          <div class="progress-text">{{ Math.round(progressPercentage) }}% Complete</div>
        </div>
      </div>
    </div>

    <!-- Statistics Grid -->
    <div v-if="subtitles && subtitles.length > 0" class="stats-grid">
      <div class="stat-card info">
        <div class="stat-icon">📊</div>
        <div class="stat-content">
          <div class="stat-number">{{ subtitles.length }}</div>
          <div class="stat-label">Total Subtitles</div>
        </div>
      </div>
      <div class="stat-card success">
        <div class="stat-icon">✅</div>
        <div class="stat-content">
          <div class="stat-number">{{ completedCount }}</div>
          <div class="stat-label">Completed</div>
        </div>
      </div>
      <div class="stat-card warning">
        <div class="stat-icon">⏳</div>
        <div class="stat-content">
          <div class="stat-number">{{ pendingCount }}</div>
          <div class="stat-label">Pending</div>
        </div>
      </div>
      <div class="stat-card primary">
        <div class="stat-icon">🔗</div>
        <div class="stat-content">
          <div class="stat-number">{{ processedChunks }}</div>
          <div class="stat-label">Processed Chunks</div>
        </div>
      </div>
    </div>

    <!-- Chunk Status -->
    <div v-if="chunks && chunks.length > 1" class="card chunks-card">
      <div class="card-header">
        <div class="card-icon">🧩</div>
        <h3 class="card-title">Chunk Processing Status</h3>
      </div>
      <div class="card-content">
        <div class="chunk-grid">
          <div
            v-for="(chunk, index) in chunks"
            :key="index"
            class="chunk-card"
            :class="getChunkStatusClass(chunk.status)"
          >
            <div class="chunk-header">
              <div class="chunk-title">Chunk {{ index + 1 }}</div>
              <div class="chunk-status-indicator" :class="chunk.status">
                <div v-if="chunk.status === 'processing'" class="loading-spinner small"></div>
                <span class="status-dot" :class="chunk.status"></span>
              </div>
            </div>
            <div class="chunk-info">
              <div class="chunk-time">{{ chunk.startTime }} – {{ chunk.endTime }}</div>
              <div class="chunk-count">{{ chunk.subtitles.length }} subtitles</div>
            </div>
            <div class="chunk-status-text">
              {{ getChunkStatusText(chunk.status) }}
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Downloaded Files -->
    <div v-if="downloadedFiles.length > 0" class="card downloads-card">
      <div class="card-header success">
        <div class="card-icon">📥</div>
        <h3 class="card-title">Downloaded Files ({{ downloadedFiles.length }})</h3>
      </div>
      <div class="card-content">
        <div class="downloads-grid">
          <div v-for="file in downloadedFiles" :key="file" class="download-item">
            <div class="download-icon">📄</div>
            <div class="download-name">{{ file }}</div>
            <div class="download-status">✅</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Pagination Controls -->
    <div v-if="subtitles && subtitles.length > 0" class="card pagination-card">
      <div class="card-header">
        <div class="card-icon">📄</div>
        <h3 class="card-title">Subtitle Display</h3>
      </div>
      <div class="card-content">
        <div class="pagination-controls">
          <div class="pagination-info">
            <label class="form-label">Items per page:</label>
            <select v-model="itemsPerPage" @change="currentPage = 1" class="form-select compact">
              <option value="10">10</option>
              <option value="25">25</option>
              <option value="50">50</option>
              <option value="100">100</option>
              <option value="all">All</option>
            </select>
            <span v-if="itemsPerPage !== 'all'" class="pagination-text">
              Showing {{ startIndex + 1 }}-{{ endIndex }} of {{ subtitles.length }} items
            </span>
          </div>
          
          <div v-if="itemsPerPage !== 'all'" class="pagination-buttons">
            <button @click="goToPage(1)" :disabled="currentPage === 1" class="btn btn-sm">
              ⏮️ First
            </button>
            <button @click="goToPage(currentPage - 1)" :disabled="currentPage === 1" class="btn btn-sm">
              ⏪ Previous
            </button>
            <span class="page-info">Page {{ currentPage }} / {{ totalPages }}</span>
            <button @click="goToPage(currentPage + 1)" :disabled="currentPage === totalPages" class="btn btn-sm">
              Next ⏩
            </button>
            <button @click="goToPage(totalPages)" :disabled="currentPage === totalPages" class="btn btn-sm">
              Last ⏭️
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Subtitle Table -->
    <div v-if="subtitles && subtitles.length > 0" class="table-container">
      <div class="table-header">
        <h3 class="table-title">Subtitle Content</h3>
      </div>
      <div class="table-wrapper">
        <table class="subtitle-table">
          <thead>
            <tr>
              <th class="col-index">Index</th>
              <th class="col-original">Original Content</th>
              <th class="col-translated">Translated Content</th>
              <th class="col-status">Status</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="subtitle in paginatedSubtitles" :key="subtitle.index" class="subtitle-row">
              <td class="index-cell">
                <div class="index-number">{{ subtitle.index }}</div>
              </td>
              <td class="content-cell">
                <div v-if="subtitle.startTime" class="timestamp">
                  {{ subtitle.startTime }} → {{ subtitle.endTime }}
                </div>
                <div class="subtitle-text original">{{ subtitle.text }}</div>
              </td>
              <td class="content-cell">
                <div v-if="subtitle.startTime" class="timestamp">
                  {{ subtitle.startTime }} → {{ subtitle.endTime }}
                </div>
                <div v-if="subtitle.translatedText" class="subtitle-text translated">
                  {{ subtitle.translatedText }}
                </div>
                <div v-else class="subtitle-text placeholder">
                  Not translated yet
                </div>
              </td>
              <td class="status-cell">
                <div class="status-wrapper">
                  <div v-if="subtitle.status === 'processing'" class="loading-spinner small"></div>
                  <span class="status-badge" :class="getStatusBadgeClass(subtitle.status)">
                    {{ getStatusText(subtitle.status) }}
                  </span>
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- Empty State -->
    <div v-if="!subtitles || subtitles.length === 0" class="empty-state">
      <div class="empty-content">
        <div class="empty-icon">📝</div>
        <div class="empty-title">No Subtitle Data Available</div>
        <div class="empty-description">
          Please upload a .txt or .srt file to start the translation process
        </div>
        <div class="empty-actions">
          <label for="file-upload" class="btn btn-primary">
            <span class="btn-icon">📄</span>
            <span>Upload Subtitle File</span>
          </label>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  name: "SubtitleTranslator",
  data() {
    return {
      apiKey: "",
      subtitles: [],
      fileContent: "",
      folderPath: null,
      isRunning: false,
      message: "",
      chunks: [],
      currentChunkIndex: 0,
      processedChunks: 0,
      downloadedFiles: [],
      sourceLanguage: "chinese",
      targetLanguage: "vietnamese",
      selectedFileName: "",
      
      // Pagination
      currentPage: 1,
      itemsPerPage: 25,

      // Loading states
      apiLoading: false,
      fileLoading: false,
      folderLoading: false,

      // Language mappings
      languageNames: {
        chinese: "tiếng Trung",
        english: "tiếng Anh",
        japanese: "tiếng Nhật",
        korean: "tiếng Hàn",
        french: "tiếng Pháp",
        german: "tiếng Đức",
        spanish: "tiếng Tây Ban Nha",
        thai: "tiếng Thái",
        vietnamese: "tiếng Việt",
      },
    };
  },

  computed: {
    completedCount() {
      return this.subtitles.filter((s) => s.status === "success").length;
    },
    pendingCount() {
      return this.subtitles.filter(
        (s) => s.status === "pending" || s.status === "Prepare"
      ).length;
    },
    progressPercentage() {
      if (this.chunks.length === 0) return 0;
      return (this.processedChunks / this.chunks.length) * 100;
    },
    totalDuration() {
      if (this.subtitles.length === 0) return "00:00:00";
      const lastSubtitle = this.subtitles[this.subtitles.length - 1];
      return lastSubtitle.endTime || "00:00:00";
    },
    totalPages() {
      if (this.itemsPerPage === 'all') return 1;
      return Math.ceil(this.subtitles.length / parseInt(this.itemsPerPage));
    },
    startIndex() {
      if (this.itemsPerPage === 'all') return 0;
      return (this.currentPage - 1) * parseInt(this.itemsPerPage);
    },
    endIndex() {
      if (this.itemsPerPage === 'all') return this.subtitles.length;
      const end = this.startIndex + parseInt(this.itemsPerPage);
      return Math.min(end, this.subtitles.length);
    },
    paginatedSubtitles() {
      if (this.itemsPerPage === 'all') {
        return this.subtitles;
      }
      return this.subtitles.slice(this.startIndex, this.endIndex);
    },
  },

  mounted() {
    // Load saved settings
    const savedKey = localStorage.getItem("api-chatgpt-key");
    if (savedKey) {
      this.apiKey = savedKey;
    }

    const savedSourceLang = localStorage.getItem("source_language");
    if (savedSourceLang) {
      this.sourceLanguage = savedSourceLang;
    }

    const savedTargetLang = localStorage.getItem("target_language");
    if (savedTargetLang) {
      this.targetLanguage = savedTargetLang;
    }

    const savedItemsPerPage = localStorage.getItem("items_per_page");
    if (savedItemsPerPage) {
      this.itemsPerPage = savedItemsPerPage;
    }
  },

  watch: {
    apiKey() {
      this.saveApiKey();
    },
    sourceLanguage() {
      localStorage.setItem("source_language", this.sourceLanguage);
    },
    targetLanguage() {
      localStorage.setItem("target_language", this.targetLanguage);
    },
    itemsPerPage() {
      localStorage.setItem("items_per_page", this.itemsPerPage);
    },
  },

  methods: {
    // Pagination methods
    goToPage(page) {
      if (page >= 1 && page <= this.totalPages) {
        this.currentPage = page;
      }
    },

    // Choose folder for saving files
    async chooseFolder() {
      this.folderLoading = true;
      try {
        if (window.require) {
          const { dialog } = window.require("electron").remote;
          const result = await dialog.showOpenDialog({
            properties: ["openDirectory"],
          });
          if (!result.canceled && result.filePaths.length > 0) {
            this.folderPath = result.filePaths[0];
            this.message = "Đã chọn: " + this.folderPath;
          } else {
            this.message = "Chưa chọn thư mục.";
          }
        } else if (window.electronAPI && window.electronAPI.chooseFolder) {
          this.folderPath = await window.electronAPI.chooseFolder();
          if (this.folderPath) {
            this.message = "Đã chọn: " + this.folderPath;
          } else {
            this.message = "Chưa chọn thư mục.";
          }
        } else if (window.showDirectoryPicker) {
          const dirHandle = await window.showDirectoryPicker();
          this.folderPath = dirHandle.name;
          this.message = "Đã chọn: " + this.folderPath;
        } else {
          this.folderPath = "Downloads (mặc định)";
          alert("Trình duyệt không hỗ trợ chọn thư mục. File sẽ được lưu vào thư mục Downloads.");
        }
      } catch (error) {
        console.error("Error selecting folder:", error);
        this.folderPath = "Downloads (mặc định)";
        alert("Không thể chọn thư mục. File sẽ được lưu vào thư mục Downloads.");
      } finally {
        this.folderLoading = false;
      }
    },

    // Handle file upload
    handleFile(event) {
      const file = event.target.files[0];
      if (!file) return;

      this.selectedFileName = file.name;
      this.fileLoading = true;
      const reader = new FileReader();
      reader.onload = () => {
        this.fileContent = reader.result;
        console.log("File content loaded:", this.fileContent.substring(0, 200) + "...");
        
        this.parseSubtitles(this.fileContent);
        this.createChunks();
        this.downloadedFiles = [];
        this.currentPage = 1;
        this.fileLoading = false;
      };
      reader.readAsText(file, "utf-8");
    },

    // Parse SRT content into subtitles array
    parseSubtitles(srtText) {
      const newSubtitles = [];
      const blocks = srtText.trim().split("\n\n");

      blocks.forEach((block) => {
        const lines = block.split("\n");
        if (lines.length >= 3) {
          const index = parseInt(lines[0]);
          const timeRange = lines[1];
          const text = lines.slice(2).join("\n");

          const timeRangeParts = timeRange.split(" --> ");
          const startTime = timeRangeParts[0] ? timeRangeParts[0].trim() : "";
          const endTime = timeRangeParts[1] ? timeRangeParts[1].trim() : "";

          newSubtitles.push({
            index: index,
            startTime: startTime,
            endTime: endTime,
            text: text,
            translatedText: "",
            status: "pending",
          });
        }
      });

      this.subtitles = newSubtitles;
      console.log("Parsed subtitles:", newSubtitles.length);
    },

    // Convert time string to seconds
    timeToSeconds(timeStr) {
      if (!timeStr) return 0;
      const parts = timeStr.split(":");
      const seconds = parseFloat(parts[2].replace(",", "."));
      return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + seconds;
    },

    // Convert seconds to time string
    secondsToTime(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      const ms = Math.floor((seconds % 1) * 1000);

      return (
        hours.toString().padStart(2, "0") +
        ":" +
        minutes.toString().padStart(2, "0") +
        ":" +
        secs.toString().padStart(2, "0") +
        "," +
        ms.toString().padStart(3, "0")
      );
    },

    // Create chunks of subtitles
    createChunks() {
      if (this.subtitles.length === 0) return;

      const newChunks = [];
      const maxChunkDuration = 180; // 3 minutes
      let currentChunk = [];
      let chunkStartTime = 0;

      for (let i = 0; i < this.subtitles.length; i++) {
        const subtitle = this.subtitles[i];
        const subtitleStartTime = this.timeToSeconds(subtitle.startTime);
        const subtitleEndTime = this.timeToSeconds(subtitle.endTime);

        if (currentChunk.length === 0) {
          chunkStartTime = subtitleStartTime;
        }

        const chunkDuration = subtitleEndTime - chunkStartTime;

        if (chunkDuration > maxChunkDuration && currentChunk.length > 0) {
          newChunks.push({
            subtitles: currentChunk.slice(),
            startTime: this.secondsToTime(chunkStartTime),
            endTime: currentChunk[currentChunk.length - 1].endTime,
            status: "pending",
            fileName: null,
          });

          currentChunk = [subtitle];
          chunkStartTime = subtitleStartTime;
        } else {
          currentChunk.push(subtitle);
        }
      }

      if (currentChunk.length > 0) {
        newChunks.push({
          subtitles: currentChunk.slice(),
          startTime: this.secondsToTime(chunkStartTime),
          endTime: currentChunk[currentChunk.length - 1].endTime,
          status: "pending",
          fileName: null,
        });
      }

      this.chunks = newChunks;
      console.log("Created chunks:", newChunks.length);
    },

    // Generate translation prompt
    generateTranslationPrompt(chunkSrtContent) {
      const sourceLangName = this.languageNames[this.sourceLanguage];
      const targetLangName = this.languageNames[this.targetLanguage];

      return `Bạn là một chuyên gia dịch thuật và làm phụ đề phim. 
Nhiệm vụ của bạn: 
1. Dịch tất cả các đoạn hội thoại dưới đây từ ${sourceLangName} sang ${targetLangName}, giữ nguyên nghĩa tự nhiên, dễ hiểu và sát ngữ cảnh. 
2. Xuất kết quả dưới định dạng phụ đề chuẩn .srt, có đánh số thứ tự, thời gian bắt đầu và kết thúc theo chuẩn phụ đề (giữ nguyên mốc thời gian từ dữ liệu gốc).
3. Chỉ xuất ra nội dung phụ đề .srt, không giải thích thêm gì khác.

Dưới đây là dữ liệu ${sourceLangName} kèm timestamp để bạn dịch và tạo phụ đề:
${chunkSrtContent}

Hãy bắt đầu ngay bây giờ.`;
    },

    // Generate filename for chunk
    generateChunkFileName(chunkIndex, totalChunks) {
      const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
      if (totalChunks === 1) {
        return `sub_${timestamp}.srt`;
      }
      return `sub_${(chunkIndex + 1).toString().padStart(2, '0')}.srt`;
    },

    // Main processing function
    async start() {
      if (this.isRunning) return;

      if (!this.apiKey) {
        alert("Vui lòng nhập API Key.");
        return;
      }

      if (!this.folderPath) {
        alert("Vui lòng chọn thư mục lưu.");
        return;
      }

      if (!this.fileContent) {
        alert("Vui lòng chọn file để xử lý.");
        return;
      }

      this.isRunning = true;
      this.processedChunks = 0;
      this.downloadedFiles = [];

      try {
        for (let i = 0; i < this.chunks.length; i++) {
          this.currentChunkIndex = i;
          const chunk = this.chunks[i];

          chunk.status = "processing";

          const chunkSrtContent = this.createSrtFromSubtitles(chunk.subtitles);
          const prompt = this.generateTranslationPrompt(chunkSrtContent);

          try {
            const translatedSrt = await this.generateSrt(prompt);
            const translatedSubtitles = this.parseTranslatedChunk(translatedSrt);
            const fileName = this.generateChunkFileName(i, this.chunks.length);
            chunk.fileName = fileName;

            await this.saveTranslatedFile(translatedSrt, fileName);
            this.downloadedFiles.push(fileName);

            chunk.status = "success";

            chunk.subtitles.forEach((subtitle) => {
              const originalIndex = this.subtitles.findIndex(
                (s) => s.index === subtitle.index
              );
              if (originalIndex !== -1) {
                this.subtitles[originalIndex].status = "success";
                const translatedSubtitle = translatedSubtitles.find(
                  (ts) => ts.index === subtitle.index
                );
                if (translatedSubtitle) {
                  this.subtitles[originalIndex].translatedText = translatedSubtitle.text;
                }
              }
            });

            console.log(`Chunk ${i + 1} completed and saved as ${fileName}`);

          } catch (error) {
            console.error(`Error processing chunk ${i + 1}:`, error);
            chunk.status = "error";

            chunk.subtitles.forEach((subtitle) => {
              const originalIndex = this.subtitles.findIndex(
                (s) => s.index === subtitle.index
              );
              if (originalIndex !== -1) {
                this.subtitles[originalIndex].status = "error";
              }
            });
          }

          this.processedChunks++;

          if (i < this.chunks.length - 1) {
            await new Promise((resolve) => setTimeout(resolve, 1000));
          }
        }

        const successfulChunks = this.chunks.filter(chunk => chunk.status === "success").length;
        if (successfulChunks > 0) {
          alert(`Hoàn thành! Đã dịch và lưu ${successfulChunks} file thành công.`);
        } else {
          alert("Không có đoạn nào được dịch thành công.");
        }

      } catch (error) {
        console.error("Error during processing:", error);
        alert("Có lỗi xảy ra: " + (error.message || "Unknown error"));
      } finally {
        this.isRunning = false;
      }
    },

    // Create SRT content from subtitles array
    createSrtFromSubtitles(subtitles) {
      return subtitles
        .map((subtitle) => {
          return (
            subtitle.index +
            "\n" +
            subtitle.startTime +
            " --> " +
            subtitle.endTime +
            "\n" +
            subtitle.text
          );
        })
        .join("\n\n");
    },

    // Parse translated chunk response
    parseTranslatedChunk(srtText) {
      const newSubtitles = [];
      const blocks = srtText.trim().split("\n\n");

      blocks.forEach((block) => {
        const lines = block.split("\n");
        if (lines.length >= 3) {
          const index = parseInt(lines[0]);
          const timeRange = lines[1];
          const text = lines.slice(2).join("\n");

          const timeRangeParts = timeRange.split(" --> ");
          const startTime = timeRangeParts[0] ? timeRangeParts[0].trim() : "";
          const endTime = timeRangeParts[1] ? timeRangeParts[1].trim() : "";

          newSubtitles.push({
            index: index,
            startTime: startTime,
            endTime: endTime,
            text: text,
            status: "success",
          });
        }
      });

      return newSubtitles;
    },

    // Call ChatGPT API for translation
    async generateSrt(prompt) {
      const response = await fetch(
        "https://gpt1.shupremium.com/v1/chat/completions",
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${this.apiKey}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            model: "gpt-4.1",
            messages: [{ role: "user", content: prompt }],
            temperature: 0.7,
          }),
        }
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.message || `API Error: ${response.status}`);
      }

      const data = await response.json();
      return data.choices[0].message.content;
    },

    // Save translated file
    async saveTranslatedFile(content, fileName) {
      try {
        if (window.require) {
          const fs = window.require("fs");
          const path = window.require("path");
          const filePath = path.join(this.folderPath, fileName);
          fs.writeFileSync(filePath, content, "utf8");
        } else if (window.electronAPI && window.electronAPI.saveToFolder) {
          const buffer = new TextEncoder().encode(content);
          await window.electronAPI.saveToFolder(
            this.folderPath,
            fileName,
            buffer
          );
        } else {
          const blob = new Blob([content], {
            type: "text/plain;charset=utf-8",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = fileName;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }
      } catch (error) {
        console.error("Error saving file:", error);
        throw error;
      }
    },

    // Status helper methods
    getStatusClass(status) {
      switch (status) {
        case "success": return "status-success";
        case "pending": return "status-pending";
        case "error": return "status-error";
        case "processing": return "status-processing";
        default: return "status-pending";
      }
    },

    getStatusText(status) {
      switch (status) {
        case "success": return "Hoàn thành";
        case "pending": return "Chờ xử lý";
        case "error": return "Lỗi";
        case "processing": return "Đang xử lý";
        default: return "Chờ xử lý";
      }
    },

    getStatusBadgeClass(status) {
      switch (status) {
        case "success": return "badge-success";
        case "pending": return "badge-warning";
        case "error": return "badge-danger";
        case "processing": return "badge-primary";
        default: return "badge-warning";
      }
    },

    getChunkStatusClass(status) {
      return "chunk-" + status;
    },

    getChunkStatusText(status) {
      switch (status) {
        case "success": return "✅ Hoàn thành";
        case "pending": return "⏸️ Chờ xử lý";
        case "error": return "❌ Lỗi";
        case "processing": return "⏳ Đang xử lý";
        default: return "⏸️ Chờ xử lý";
      }
    },

    saveApiKey() {
      localStorage.setItem("api-chatgpt-key", this.apiKey);
    },
  },
};
</script>

<style scoped>
.translator-container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
  min-height: 100vh;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

/* Header Section */
.header-section {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 16px;
  padding: 24px;
  margin-bottom: 24px;
  color: white;
  box-shadow: 0 8px 32px rgba(102, 126, 234, 0.3);
}

.header-content {
  display: flex;
  align-items: center;
  gap: 16px;
}

.header-icon {
  font-size: 32px;
  background: rgba(255, 255, 255, 0.2);
  padding: 12px;
  border-radius: 12px;
  backdrop-filter: blur(10px);
}

.header-title {
  font-size: 28px;
  font-weight: 700;
  margin: 0 0 4px 0;
}

.header-subtitle {
  font-size: 16px;
  margin: 0;
  opacity: 0.9;
}

/* Card Styles */
.card {
  background: white;
  border-radius: 16px;
  margin-bottom: 20px;
  overflow: hidden;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(10px);
}

.card-header {
  padding: 16px 20px;
  display: flex;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid #f0f0f0;
  font-weight: 600;
}

.card-header.primary {
  background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
  color: white;
  border-bottom: none;
}

.card-header.info {
  background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
  color: #2d3748;
  border-bottom: none;
}

.card-header.warning {
  background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
  color: #744210;
  border-bottom: none;
}

.card-header.success {
  background: linear-gradient(135deg, #d299c2 0%, #fef9d7 100%);
  color: #22543d;
  border-bottom: none;
}

.card-icon {
  font-size: 20px;
}

.card-title {
  font-size: 18px;
  margin: 0;
}

.card-content {
  padding: 20px;
}

/* Form Elements */
.form-group {
  margin-bottom: 16px;
}

.form-label {
  display: block;
  font-size: 14px;
  font-weight: 600;
  color: #2d3748;
  margin-bottom: 8px;
}

.form-input {
  width: 100%;
  padding: 12px 16px;
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  font-size: 14px;
  background: white;
  transition: all 0.3s;
}

.form-input:focus {
  outline: none;
  border-color: #4facfe;
  box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
}

.form-select {
  width: 100%;
  padding: 12px 16px;
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  font-size: 14px;
  background: white;
  cursor: pointer;
  transition: all 0.3s;
}

.form-select:focus {
  outline: none;
  border-color: #4facfe;
  box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
}

.form-select.compact {
  width: auto;
  min-width: 120px;
}

/* Input Wrapper */
.input-wrapper {
  position: relative;
}

.api-status {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #e2e8f0;
}

.status-dot.active {
  background: #48bb78;
  box-shadow: 0 0 8px rgba(72, 187, 120, 0.4);
}

.status-text {
  font-size: 12px;
  font-weight: 500;
  color: #48bb78;
}

/* Language Grid */
.language-grid {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  gap: 20px;
  align-items: end;
}

.arrow-container {
  display: flex;
  justify-content: center;
  align-items: center;
  padding-bottom: 8px;
}

.arrow-icon {
  font-size: 24px;
  font-weight: bold;
  color: #4facfe;
  background: linear-gradient(135deg, #4facfe, #00f2fe);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

/* File Management */
.file-grid {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 20px;
  align-items: end;
}

.file-input-wrapper {
  position: relative;
}

.file-input {
  position: absolute;
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer;
}

.file-input-label {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 20px;
  background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
  border: 2px dashed #cbd5e0;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.3s;
  font-weight: 500;
  color: #4a5568;
}

.file-input-label:hover {
  background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
  border-color: #4facfe;
}

.upload-icon {
  font-size: 18px;
}

.file-name {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
  padding: 8px 12px;
  background: #f7fafc;
  border-radius: 8px;
  font-size: 13px;
  color: #4a5568;
}

.file-icon {
  font-size: 14px;
}

.folder-btn {
  white-space: nowrap;
}

.folder-display {
  margin-top: 16px;
  padding: 12px 16px;
  background: linear-gradient(135deg, #f0fff4 0%, #c6f6d5 100%);
  border-radius: 12px;
  border-left: 4px solid #48bb78;
}

.folder-info {
  display: flex;
  align-items: center;
  gap: 8px;
}

.folder-icon {
  font-size: 16px;
}

.folder-path {
  font-family: 'Monaco', 'Menlo', monospace;
  font-size: 13px;
  color: #22543d;
  font-weight: 500;
}

/* Info Grid */
.info-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
}

.info-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 16px;
  background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
  border-radius: 12px;
  border-left: 4px solid #4facfe;
}

.info-icon {
  font-size: 24px;
}

.info-number {
  font-size: 20px;
  font-weight: 700;
  color: #2d3748;
}

.info-label {
  font-size: 14px;
  font-weight: 600;
  color: #4a5568;
}

.info-desc {
  font-size: 12px;
  color: #718096;
}

/* Buttons */
.btn {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 12px 20px;
  border: none;
  border-radius: 12px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s;
  text-decoration: none;
}

.btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.btn-primary {
  background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
  color: white;
  box-shadow: 0 4px 15px rgba(79, 172, 254, 0.3);
}

.btn-primary:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(79, 172, 254, 0.4);
}

.btn-start {
  width: 100%;
  padding: 16px 24px;
  font-size: 16px;
  background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
  color: white;
  box-shadow: 0 4px 15px rgba(72, 187, 120, 0.3);
}

.btn-start:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(72, 187, 120, 0.4);
}

.btn-start.processing {
  background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
  box-shadow: 0 4px 15px rgba(237, 137, 54, 0.3);
}

.btn-sm {
  padding: 6px 12px;
  font-size: 12px;
}

.btn-content {
  display: flex;
  align-items: center;
  gap: 8px;
}

.btn-icon {
  font-size: 16px;
}

/* Progress Section */
.progress-section {
  margin-top: 16px;
}

.progress-bar {
  width: 100%;
  height: 8px;
  background: #edf2f7;
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: 8px;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #48bb78, #38a169);
  transition: width 0.3s;
  border-radius: 4px;
}

.progress-text {
  text-align: center;
  font-size: 14px;
  font-weight: 600;
  color: #4a5568;
}

/* Statistics Grid */
.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
  margin-bottom: 20px;
}

.stat-card {
  background: white;
  border-radius: 16px;
  padding: 20px;
  display: flex;
  align-items: center;
  gap: 16px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
  border-left: 4px solid #e2e8f0;
  transition: all 0.3s;
}

.stat-card:hover {
  transform: translateY(-4px);
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
}

.stat-card.info {
  border-left-color: #4facfe;
  background: linear-gradient(135deg, #ffffff 0%, #f0f9ff 100%);
}

.stat-card.success {
  border-left-color: #48bb78;
  background: linear-gradient(135deg, #ffffff 0%, #f0fff4 100%);
}

.stat-card.warning {
  border-left-color: #ed8936;
  background: linear-gradient(135deg, #ffffff 0%, #fffaf0 100%);
}

.stat-card.primary {
  border-left-color: #667eea;
  background: linear-gradient(135deg, #ffffff 0%, #faf5ff 100%);
}

.stat-icon {
  font-size: 28px;
}

.stat-number {
  font-size: 24px;
  font-weight: 700;
  color: #2d3748;
  margin-bottom: 4px;
}

.stat-label {
  font-size: 14px;
  color: #718096;
  font-weight: 500;
}

/* Chunk Grid */
.chunk-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 16px;
}

.chunk-card {
  background: white;
  border-radius: 12px;
  padding: 16px;
  border-left: 4px solid #e2e8f0;
  transition: all 0.3s;
}

.chunk-card.chunk-pending {
  border-left-color: #cbd5e0;
  background: linear-gradient(135deg, #ffffff 0%, #f7fafc 100%);
}

.chunk-card.chunk-processing {
  border-left-color: #ed8936;
  background: linear-gradient(135deg, #ffffff 0%, #fffaf0 100%);
  box-shadow: 0 4px 20px rgba(237, 137, 54, 0.2);
}

.chunk-card.chunk-success {
  border-left-color: #48bb78;
  background: linear-gradient(135deg, #ffffff 0%, #f0fff4 100%);
}

.chunk-card.chunk-error {
  border-left-color: #f56565;
  background: linear-gradient(135deg, #ffffff 0%, #fef5e7 100%);
}

.chunk-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.chunk-title {
  font-weight: 600;
  color: #2d3748;
}

.chunk-status-indicator {
  display: flex;
  align-items: center;
  gap: 6px;
}

.chunk-status-indicator .status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
}

.chunk-status-indicator .status-dot.pending {
  background: #cbd5e0;
}

.chunk-status-indicator .status-dot.processing {
  background: #ed8936;
}

.chunk-status-indicator .status-dot.success {
  background: #48bb78;
}

.chunk-status-indicator .status-dot.error {
  background: #f56565;
}

.chunk-info {
  margin-bottom: 8px;
}

.chunk-time {
  font-family: 'Monaco', 'Menlo', monospace;
  font-size: 12px;
  color: #718096;
  margin-bottom: 4px;
}

.chunk-count {
  font-size: 12px;
  color: #4a5568;
}

.chunk-status-text {
  font-size: 12px;
  font-weight: 500;
  color: #4a5568;
}

/* Downloads Grid */
.downloads-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 12px;
}

.download-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  background: linear-gradient(135deg, #f0fff4 0%, #c6f6d5 100%);
  border-radius: 12px;
  border-left: 4px solid #48bb78;
}

.download-icon {
  font-size: 18px;
}

.download-name {
  flex: 1;
  font-size: 13px;
  font-weight: 500;
  color: #22543d;
}

.download-status {
  font-size: 16px;
}

/* Pagination */
.pagination-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 16px;
  flex-wrap: wrap;
}

.pagination-info {
  display: flex;
  align-items: center;
  gap: 12px;
}

.pagination-text {
  font-size: 14px;
  color: #718096;
}

.pagination-buttons {
  display: flex;
  align-items: center;
  gap: 8px;
}

.page-info {
  font-size: 14px;
  font-weight: 500;
  color: #4a5568;
  margin: 0 8px;
}

/* Table */
.table-container {
  background: white;
  border-radius: 16px;
  overflow: hidden;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
  margin-bottom: 20px;
}

.table-header {
  padding: 16px 20px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
}

.table-title {
  font-size: 18px;
  font-weight: 600;
  margin: 0;
}

.table-wrapper {
  overflow-x: auto;
}

.subtitle-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 14px;
}

.subtitle-table th {
  padding: 16px 12px;
  text-align: left;
  font-weight: 600;
  color: #2d3748;
  background: #f7fafc;
  border-bottom: 2px solid #e2e8f0;
}

.subtitle-table td {
  padding: 16px 12px;
  border-bottom: 1px solid #f0f0f0;
  vertical-align: top;
}

.col-index {
  width: 80px;
  text-align: center;
}

.col-original,
.col-translated {
  width: 35%;
}

.col-status {
  width: 120px;
  text-align: center;
}

.subtitle-row:hover {
  background: #f7fafc;
}

.index-cell {
  text-align: center;
}

.index-number {
  font-weight: 600;
  color: #4a5568;
  background: #edf2f7;
  padding: 4px 8px;
  border-radius: 6px;
  display: inline-block;
}

.content-cell {
  line-height: 1.6;
}

.timestamp {
  font-family: 'Monaco', 'Menlo', monospace;
  font-size: 11px;
  color: #718096;
  margin-bottom: 8px;
  background: #f7fafc;
  padding: 2px 6px;
  border-radius: 4px;
  display: inline-block;
}

.subtitle-text {
  line-height: 1.6;
}

.subtitle-text.original {
  color: #2d3748;
}

.subtitle-text.translated {
  color: #4facfe;
  font-weight: 500;
}

.subtitle-text.placeholder {
  color: #a0aec0;
  font-style: italic;
}

.status-cell {
  text-align: center;
}

.status-wrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

.status-badge {
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
}

.status-badge.badge-success {
  background: #c6f6d5;
  color: #22543d;
}

.status-badge.badge-warning {
  background: #fbd38d;
  color: #744210;
}

.status-badge.badge-danger {
  background: #fed7d7;
  color: #742a2a;
}

.status-badge.badge-primary {
  background: #bee3f8;
  color: #2c5282;
}

/* Loading Spinner */
.loading-spinner {
  width: 20px;
  height: 20px;
  border: 2px solid #f3f3f3;
  border-top: 2px solid #4facfe;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.loading-spinner.small {
  width: 16px;
  height: 16px;
  border-width: 2px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Empty State */
.empty-state {
  background: white;
  border-radius: 16px;
  padding: 60px 20px;
  text-align: center;
  margin-bottom: 20px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
}

.empty-icon {
  font-size: 64px;
  margin-bottom: 20px;
  opacity: 0.6;
}

.empty-title {
  font-size: 24px;
  font-weight: 600;
  color: #2d3748;
  margin-bottom: 12px;
}

.empty-description {
  font-size: 16px;
  color: #718096;
  line-height: 1.6;
  margin-bottom: 24px;
  max-width: 400px;
  margin-left: auto;
  margin-right: auto;
}

.empty-actions {
  display: flex;
  justify-content: center;
}

/* Responsive Design */
@media (max-width: 768px) {
  .translator-container {
    padding: 16px;
  }

  .header-content {
    flex-direction: column;
    text-align: center;
    gap: 12px;
  }

  .language-grid {
    grid-template-columns: 1fr;
    gap: 16px;
  }

  .arrow-container {
    order: 3;
  }

  .file-grid {
    grid-template-columns: 1fr;
    gap: 16px;
  }

  .info-grid {
    grid-template-columns: 1fr;
  }

  .stats-grid {
    grid-template-columns: repeat(2, 1fr);
  }

  .chunk-grid {
    grid-template-columns: 1fr;
  }

  .downloads-grid {
    grid-template-columns: 1fr;
  }

  .pagination-controls {
    flex-direction: column;
    align-items: stretch;
  }

  .pagination-buttons {
    justify-content: center;
  }

  .subtitle-table {
    font-size: 12px;
  }

  .subtitle-table th,
  .subtitle-table td {
    padding: 12px 8px;
  }
}

@media (max-width: 480px) {
  .stats-grid {
    grid-template-columns: 1fr;
  }

  .stat-card {
    flex-direction: column;
    text-align: center;
    gap: 8px;
  }

  .pagination-buttons {
    flex-wrap: wrap;
    gap: 4px;
  }

  .btn-sm {
    padding: 4px 8px;
    font-size: 11px;
  }
}
</style>